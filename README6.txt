					Сортировка выбором (Selection Sort)

	Определение:
Сортировка выбором (Selection Sort) — это простой алгоритм сортировки, который работает по принципу последовательного выбора минимального (или максимального) элемента из неотсортированной части массива и перемещения его в начало (или конец) отсортированной части
	Анализ:  
1.Программа выполняет следующие действия:
Функция selectionSort проходит по массиву, каждый раз предполагая, что текущий элемент — минимальный.
Внутренний цикл for ищет наименьший элемент среди оставшихся.
Найденный минимальный элемент меняется местами с текущим элементом (swap(arr[i], arr[minIndex])).
После завершения всех итераций массив становится отсортированным по возрастанию.
В main() создаётся массив чисел, вызывается функция сортировки и выводится результат.
	Временная сложность: O(n²)
	Почему O(n²):
Сортировка выбором имеет временную сложность O(n²), потому что в алгоритме используются два вложенных цикла: внешний цикл по всем элементам массива и внутренний — для поиска минимального в оставшейся части массива	


					Сортировка обменом (пузырьком) (Bubble Sort):

	Определение:
Сортировка обменом (пузырьком) (Bubble Sort) — это метод упорядочивания элементов массива, при котором соседние элементы сравниваются попарно. Если предыдущий элемент больше следующего (при сортировке по возрастанию), они меняются местами. Таким образом, после каждого прохода наибольший элемент «всплывает» в конец массива, подобно пузырьку воздуха в воде.
	Анализ:
Код сортировки пузырьком работает так: программа сравнивает соседние элементы массива и меняет их местами, если левый больше правого. После каждого прохода самый большой элемент «всплывает» в конец, и процесс повторяется, пока массив не станет отсортированным.​
Сортировка выполняется с помощью двух вложенных циклов for.
Внешний цикл определяет количество проходов по массиву, а внутренний цикл сравнивает пары элементов и выполняет обмен, если нужно. В каждой итерации внутреннего цикла выполняется меньше сравнений, потому что последние элементы уже упорядочены.
	Временная сложность: O(n²)
	Почему O(n²):
потому что необходимо выполнить примерно n×(n−1)/2 сравнений и возможных обменов.

					Сортировка вставками (Insertion Sort):

	Определение:
Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки, в котором элементы массива обрабатываются последовательно: каждый новый элемент вставляется в подходящее место среди уже отсортированных элементов.
	Анализ:
Код реализует сортировку вставками. На каждом шаге:
Выбираем очередной элемент (начиная со второго).
Сравнием его с элементами слева, которые уже отсортированы.
Сдвигаем все элементы, которые больше, вправо на одну позицию.
Вставляем выбранный элемент на своё место.
В результате, после каждой итерации левая часть массива всё больше отсортирована, а к концу работы весь массив становится отсортированным.
	Временная сложность: O(n²)
	Почему O(n²): В наихудшем случае алгоритм выполняет примерно половину от n² операций, потому что каждый новый элемент сравнивается и сдвигается относительно всех предыдущих.  1 + 2 + 3 + ... + (n-1) = n*(n-1)/2.


					Сортировка слиянием (Merge Sort)
	Определение:
Сортировка слиянием (Merge Sort) — это эффективный алгоритм сортировки, основанный на принципе «разделяй и властвуй».Основная идея слияния двух отсортированных списков заключается в поочередном выборе минимального элемента из начала каждого списка и добавлении его в результирующий массив. Этот процесс повторяется, пока элементы в обоих подмассивах не будут полностью использованы.
	Алгоритм:
Деление: программа рекурсивно делит массив на две части — пока каждая часть не станет по одному элементу.
Слияние: затем две отсортированные части объединяются в один общий массив, сравнивая элементы по очереди и добавляя меньший сначала.
Результат: после завершения всех рекурсий весь массив становится полностью отсортированным.
	Временна сложность: O(n log n)
	Почему O(nlogn): 
потому что алгоритм состоит из двух вложенных процессов :​
еление массива — на каждом шаге массив делится пополам. Это происходит примерно log n раз, потому что после каждого деления размер уменьшается в 2 раза.
Слияние частей — на каждом уровне рекурсии выполняется операция слияния всех элементов, которая обрабатывает каждый элемент один раз — то есть занимает O(n) времени.
Просто говоря, сортировка слиянием делает 
log n уровней разбиения, и на каждом из них проходит все n элементы, что и даёт O(n log n).​


					Сортировка Шелла (Shell Sort)
	Определение: 
В основе метода лежит идея постепенного упорядочивания элементов, находящихся друг от друга на определённом расстоянии (шаге). Сначала элементы сравниваются и сортируются с большим шагом, а затем шаг постепенно уменьшается. На последнем этапе, при шаге 1, выполняется обычная сортировка вставками.
	Алгоритм: 
Код сортировки Шелла работает так :​
Делит массив на группы элементов, стоящих на расстоянии gap друг от друга (изначально gap = n // 2).
В каждой группе выполняет сортировку вставками — элементы сравниваются и переставляются, если стоят не по порядку.
После каждого прохода уменьшает шаг gap вдвое.
При шаге 1 выполняется обычная сортировка вставками, доводящая массив до полного порядка.
Таким образом, элементы постепенно «подтягиваются» ближе к своим местам, и массив быстро становится отсортированным.
	Временная сложность: O(n²)
	Почему O(n²):
Потому что в коде сортировки Шелла используется два вложенных цикла: внешний проходит по всем элементам массива, а внутренний сдвигает элементы при сравнении — каждый может выполняться до **n** раз. В худшем случае количество операций становится пропорционально n × n = O(n²).

					Быстрая сортировка (Quick Sort)
	Определение:
Быстрая сортировка (Quick Sort) — это алгоритм сортировки, основанный на принципе «разделяй и властвуй», который разделяет массив на две части относительно опорного элемента (pivot): элементы меньше него помещаются слева, а больше — справа. Затем каждая часть сортируется рекурсивно, что обеспечивает высокую эффективность
	Алгоритм:
Код быстрой сортировки работает по простому принципу :​
Выбирается опорный элемент (pivot) — обычно средний элемент массива.
Массив делится на три части: элементы меньше pivot, равные pivot и больше pivot.
Каждая часть сортируется рекурсивно, пока в подмассивах не останется по одному элементу.
Результаты объединяются: левый подмассив + pivot + правый подмассив.
Так массив быстро упорядочивается за счёт многократного деления и рекурсии.
	Временная сложность: O(n²)
	Почему O(n²):
Худшая временная сложность O(n²) возникает тогда, когда опорный элемент (pivot) выбирается неудачно — например, он оказывается наименьшим или наибольшим в массиве.​
В этом случае массив делится очень неравномерно: один подмассив содержит почти все элементы, а другой — почти пуст. Алгоритм вынужден выполнять n рекурсивных вызовов, и общее количество операций становится пропорционально n+(n−1)+(n−2)+...+1=O(n2)n+(n−1)+(n−2)+...+1=O(n²).

					Пирамидальная сортировка (Heap Sort)
	Определение:
Пирамидальная сортировка (Heap Sort) — это алгоритм сортировки сравнением, основанный на структуре данных двоичная куча (binary heap).​
Он преобразует массив в кучу (max-heap или min-heap), где каждый родительский элемент больше или меньше своих потомков. Затем корневой элемент (наибольший или наименьший) перемещается в конец массива, после чего структура кучи восстанавливается, и процесс повторяется до полной сортировки
	Алгоритм:
Код пирамидальной сортировки работает так :​
Строит кучу (heap) — массив преобразуется в двоичное дерево, где каждый родитель больше своих детей. Это выполняется циклом for (int i = n / 2 - 1; i >= 0; i--), который вызывает функцию heapify() для каждого узла снизу вверх.
Извлекает максимум — корень кучи (наибольший элемент) меняется местами с последним элементом массива.
Восстанавливает кучу — вызывается heapify() для новой вершины, чтобы снова упорядочить оставшиеся элементы.
Повторяет шаги до тех пор, пока не будут обработаны все элементы.
Результат — массив отсортирован по возрастанию.
	Временная сложность: O(n log n)
	Почему O(n log n):
Пирамидальная сортировка имеет сложность O(nlogn), потому что:​
Каждый элемент удаляется из кучи n раз.
Каждое удаление сопровождается восстановлением кучи функцией heapify, которое занимает O(log n) шагов — это высота дерева.
В итоге общее число операций: n × logn=O(nlogn). Таким образом, сортировка требует логарифмическое время для каждого из n элементов.

					Последовательный (линейный) поиск (Linear Search)
	Определение: 
Линейный (последовательный) поиск — это простой алгоритм, который последовательно сравнивает каждый элемент массива или списка с искомым значением, пока не найдёт совпадение или не дойдёт до конца структуры данных.
	Алгоритм: 
Код последовательно перебирает элементы массива с начала до конца, сравнивая каждый элемент с искомым значением. Если находит совпадение, возвращает индекс этого элемента и останавливается. Если элемент не найден после проверки всех, возвращает -1, то есть сигнал отсутствия элемента в массиве
	Временная сложность:O(n)
	Почему О(n):
Сложность линейного поиска равна O(n), потому что алгоритм в худшем случае сравнивает каждый элемент массива с искомым значением.​
Если в массиве n элементов, то выполняется n проверок — поэтому время выполнения растёт пропорционально количеству элементов.
Увеличишь массив в два раза — вдвое возрастёт и число операций, что и определяет линейную зависимость.

					Бинарный поиск (Binary Search)
	Определение:
Бинарный поиск — это алгоритм поиска элемента в отсортированном массиве данных, который работает за счёт многократного деления массива пополам. На каждом шаге алгоритм сравнивает искомый элемент со средним элементом текущей части массива и сужает область поиска либо к левой, либо к правой половине. Поиск продолжается, пока элемент не будет найден или область поиска не станет пустой.
	Алгоритм:
Код бинарного поиска работает так :​
Берётся отсортированный массив.
Находится середина массива.
Если середина равна нужному числу — поиск заканчивается.
Если нужное число больше середины — поиск продолжается в правой половине.
Если меньше — идём в левую половину.
Процесс повторяется, пока элемент не найден или пока часть массива не станет пустой.
	Временная сложность: O(log n)
	Почему O(log n): 
Сложность O(log n) у бинарного поиска из-за того, что при каждом шаге количество элементов, в которых мы ищем нужное число, уменьшается вдвое. То есть, если данных стало в 2 раза больше, то для поиска потребуется всего на 1 дополнительный шаг. Поэтому количество операций растёт очень медленно, логарифмически по отношению к размеру массива.

					Интерполирующий поиск (Interpolation Search)
	Определение:
Интерполирующий поиск — это алгоритм поиска элемента в отсортированном массиве, который, в отличие от бинарного поиска, не делит диапазон пополам, а предсказывает позицию искомого элемента, используя его значение относительно концов диапазона
	Алгоритм:
Задает границы поиска low и high.
Вычисляет индекс pos по формуле интерполяции — чем ближе значение к правому концу массива, тем дальше индекс.
Сравнивает элемент в pos с искомым значением:
если он равен — поиск завершён;
если меньше — сужает поиск вправо;
если больше — влево.
Повторяет процесс, пока элемент не найден или диапазон не сузится до пустого.
	Временная сложность: O(n)
	Почему O(n):
возникает в худшем случае, когда данные распределены неравномерно — например, элементы массива растут экспоненциально или сильно разрежены.
В этом случае формула интерполяции вычисляет позиции далеко от нужного элемента, и алгоритм фактически перебирает почти все элементы последовательно.

					Поиск по Фибоначчи (Fibonacci Search)
	Определение:
Fibonacci Search — это алгоритм поиска элемента в отсортированном массиве, который использует числа Фибоначчи для выбора позиций сравнения вместо деления массива пополам, как в бинарном поиске.
	Алгоритм:
Сначала вычисляются числа Фибоначчи, чтобы определить длину интервалов поиска.
Затем алгоритм сравнивает искомое число с элементом массива в позиции, вычисленной по этим числам.
Если число меньше — поиск продолжается слева, если больше — справа.
Это повторяется, пока не останется один элемент или не будет найден нужный.
	Временная сложность:O(log n)
	Почему O(log n): 
Сложность O(log n) потому что алгоритм каждый раз сокращает область поиска примерно в несколько раз, используя числа Фибоначчи.​
Количество проверок растёт логарифмически от размера массива, то есть при увеличении массива в 2 раза добавляется всего одна итерация поиска.