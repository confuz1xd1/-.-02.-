						Блочная (корзинная) сортировка
		Определение алгоритма:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет 
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их 
значений. После этого каждая корзина сортируется отдельно (либо тем же методом 
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины 
объединяются обратно в один массив.
		Пример кода для соответствующего алгоритма:
=>файл с кодом
		Результаты работы предложенного кода из консоли в онлайн-IDE системах: 
[0.42, 0.6, 1.41, 2.24, 2.71, 3.14, 3.33, 4.2]
	Объяснение работы алгоритма:
1. Находим минимальный и максимальный элементы
Эти значения нужны для расчёта диапазонов для корзин
  min_value = min(arr)
  max_value = max(arr)
2. Создаём пустые корзины
Количество корзин часто выбирают равным числу элементов.
  bucket_count = len(arr)
  buckets = [[] for _ in range(bucket_count)]
3. Распределяем элементы по корзинам
Каждый элеме	нт вычисляет индекс своей корзины и помещается туда.
  for num in arr:
      index = int((num - min_value) * (bucket_count - 1) / (max_value - min_value))
      buckets[index].append(num)
4. Сортируем отдельные корзины
Обычно для этого используется стандартная сортировка.
  for bucket in buckets:
      sorted_array.extend(sorted(bucket))
5. Собираем итоговый отсортированный список
Добавляем элементы из каждой корзины в результат.
  sorted_array = []
  for bucket in buckets:
      sorted_array.extend(sorted(bucket))
		Оценка временной сложности алгоритма: O(n)
		Краткое объяснение оценки временной сложности алгоритма:
Временная сложность O(n) у bucket sort объясняется тем, что:
-Массив делится на n корзин
-Элементы равномерно распределяются по корзинам (каждая содержит примерно 1 элемент),
-Сортировка внутри маленьких корзин происходит очень быстро,
-Все этапы (распределение и слияние) требуют прохода по данным один раз.
-Это даёт суммарно линейное время работы при равномерном распределении элементов .

						Блинная сортировка
		Определение алгоритма:
Блинная сортировка (pancake sort) — это метод, основанный на операции 
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые 
обменивают соседние элементы или выбирают опорные точки, здесь единственная 
разрешённая операция — переворот префикса массива до выбранного индекса.
		Пример кода для соответствующего алгоритма:
=>файл с кодом 
		Результаты работы предложенного кода из консоли в онлайн-IDE системах: 
[1, 3, 5, 6, 8, 10]
		Объяснение работы алгоритма:
Алгоритм сортировки блинов состоит из трёх основных этапов:
-Поиск максимального элемента среди оставшихся несортированных:
  max_idx = arr.index(max(arr[:size]))
-Перенос максимального элемента в начало текущей части массива:
  flip(arr, max_idx)
-Перемещение максимального элемента на финальную позицию путём второго переворота всей текущей части:
  flip(arr, size - 1)
Эти шаги повторяются до полной сортировки массива.
		Оценка временной сложности алгоритма: O(n²)
		Краткое объяснение оценки временной сложности алгоритма:
Оценка временной сложности алгоритма сортировки блинов O(n²):
1. Внешний цикл: Проходит по массиву длиной n, уменьшаясь на каждом шаге, итераций порядка n.
2. Внутреннее действие:
   - Нахождение максимального элемента: занимает O(k) операций (линейный поиск).
   - Два переворота: оба выполняются за линейное время относительно длины переворачиваемого фрагмента (O(k)).
Поскольку внутренний процесс выполняется на каждой итерации внешнего цикла, итоговая сложность равна произведению количества итераций на стоимость одной операции, то есть примерно O(n*k) ≈ O(n*n) = O(n²).

						Сортировка бусинами (гравитационная)
		Определение алгоритма:
Сортировка бусинами (bead sort), также известная как гравитационная 
сортировка, моделирует естественное поведение бусин, падающих вниз под действием 
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл 
Диннин в 2002 году. 
		Пример кода для соответствующего алгоритма:
=>файл с кодом 
		Результаты работы предложенного кода из консоли в онлайн-IDE системах: 
Отсортированный массив: [7, 5, 4, 3, 1]
		Объяснение работы алгоритма:
1) Формируем матрицу из булевых значений:
  rows = [[True]val + [False](max(arr)-val) for val in arr]
2)Переводим матрицу в столбцы:
  columns = list(zip(*rows))
3)Сортируем каждый столбец, собирая вместе все True и дополняя False:
  sorted_columns = []for col in columns:    ones = sum(col)    zeros = len(col) - ones    sorted_col = ([True]*ones + [False]*zeros)    sorted_columns.append(sorted_col)
4)Восстанавливаем порядок строк и получаем итоговую отсортированную последовательность:
  result_rows = list(zip(*sorted_columns))return [sum(row) for row in result_rows]
		Оценка временной сложности алгоритма: O(n)
		Краткое объяснение оценки временной сложности алгоритма:
Основная операция сортировки заключается в следующем:
-Каждая бусинка движется сверху вниз, пока не достигнет своего финального положения.
-Время перемещения одной бусинки зависит лишь от высоты, на которой она находится изначально.

						 Поиск скачками (Jump Search)
		Определение алгоритма:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при 
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы 
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного 
диапазона. 
		Пример кода для соответствующего алгоритма:
=>файл с кодом 
		Результаты работы предложенного кода из консоли в онлайн-IDE системах: 
Элемент 5 найден на индексе 5
		Объяснение работы алгоритма:
1)Определяем размер прыжка (step) как квадратный корень из длины массива.
  step = int(math.sqrt(len(arr)))
2)Перемещаемся вперёд на величину шага, пока текущий элемент меньше искомого.
  while arr[min(step, n)-1] < x:
      prev = step
      step += int(math.sqrt(n))
3)Проводим линейный поиск назад от последней пройденной позиции до начала текущего блока.
  for i in range(prev, min(step, n)):
      if arr[i] == x:
          return i
4)Возвращаем индекс найденного элемента или -1, если элемент отсутствует.
		Оценка временной сложности алгоритма: O(n)
		Краткое объяснение оценки временной сложности алгоритма:
Определяется размер шага step, равный примерно квадратному корню из длины массива (√n).
Массив последовательно просматривается с шагом step. Проверяется элемент на каждой остановке. Если значение становится больше искомого, значит, искомый элемент находится в предыдущем блоке.
После нахождения подходящего блока выполняется линейный поиск внутри этого блока размером порядка √n.

						Экспоненциальный поиск (Exponential Search)
		Определение алгоритма:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя 
быстро определить диапазон, в котором может находиться искомое значение, а затем 
применяет двоичный поиск в этом диапазоне.
		Пример кода для соответствующего алгоритма:
=>файл с кодом 
		Результаты работы предложенного кода из консоли в онлайн-IDE системах:
Элемент 45 найден на индексе 3
		Объяснение работы алгоритма:
-Проверка первого элемента: если элемент равен искомому, немедленно возвращаем индекс
  0.if arr[0] == x:    
      return 0
-Экспоненциальное увеличение шага: начинаем с индекса 1 и удваиваем его, пока элемент на соответствующей позиции меньше искомого. Таким образом быстро приближаемся к нужной области массива.
  i = 1while i < n and arr[i] <= x:  
      i *= 2
-Определение границ для бинарного поиска: находим верхнюю границу как минимум из текущего индекса и размера массива минус единица, нижнюю границу устанавливаем равной половине предыдущего индекса.
  low = i // 2high = min(i, n - 1)
Запуск бинарного поиска: ищем целевой элемент в указанном диапазоне с использованием стандартного бинарного поиска.
  result = binary_search(arr, low, high, x)
		Оценка временной сложности алгоритма: O(log n)
		Давайте разберём временные затраты каждой части алгоритма отдельно:
1. Экспоненциальное приближение (увеличение индекса):
Мы постепенно удваиваем индекс (1, 2, 4, 8...). Чтобы достигнуть индекса примерно approx k, нам потребуется сделать около log(k) шагов. Например, если размер массива n=1024, то мы пройдём порядка 10 итераций (так как 2^10=1024). Это даёт временную сложность O(log n).




		