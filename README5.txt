# Рекурсивная функция для нахождения макс эл в массиве 

		Алгоритм работы:
  if len(arr) == 1: — базовый случай рекурсии. Когда в массиве остается только один элемент, функция возвращает его как максимум, потому что сравнивать дальше не с чем. Это условие завершает рекурсивные вызовы и начинает возвращать значения обратно.
  max_rest = find_max(arr[1:]) — рекурсивный вызов функции для оставшейся части массива (все элементы кроме первого). Функция вызывает саму себя, сокращая задачу до меньшего массива. Этот вызов продолжается, пока не достигнет базового случая.
  return arr[0] if arr[0] > max_rest else max_rest — после того, как вычислен максимум в оставшейся части массива (в переменной max_rest), происходит сравнение первого элемента с этим максимумом. Возвращается наибольшее из них
Таким образом, функция постепенно разбивает исходный массив на все меньшие части, пока не дойдет до одного элемента. Затем сравнения начинают "подниматься" по рекурсивному стеку, на каждом уровне выбирая максимальный элемент между первым текущим и максимальным из остальной части массива.
Это классическая рекурсивная стратегия "разделяй и властвуй": разбить задачу на подзадачи (массив без первого элемента), решить подзадачу рекурсивно, а затем объединить результат (выбрать максимум).
Данный алгоритм может быть медленнее итеративного, так как создает много вызовов функций и копий частей массива, но он хорошо демонстрирует принцип рекурсии и подходит для учебных целей
		Временная сложность: O(n²)
		Почему O(n²):
-Каждый рекурсивный вызов find_max(arr[1:]) создает новый срез массива, копируя все элементы, кроме первого. Создание среза требует времени O(k), где k — длина создаваемого среза.
-В первой итерации копируется массив длиной n−1, во второй — n−2, и так далее, до длины 1.
-Итоговое время копирования составит сумму:(n−1)+(n−2)+…+1=((n−1)n)/2=O(n²)

-Каждое сравнение само по себе занимает O(1), но накладные расходы на создание срезов доминируют.

Мемоизация — это метод оптимизации рекурсивных алгоритмов, при котором результаты функций сохраняются (кэшируются) после первого вычисления с определёнными аргументами. При повторном вызове с теми же параметрами программа не выполняет повторные вычисления, а сразу возвращает сохранённый результат из кэша.
Это существенно ускоряет работу рекурсивных алгоритмов, которые часто вызывают одни и те же функции с одинаковыми аргументами, уменьшая избыточные вычисления. Например, при вычислении чисел Фибоначчи без мемоизации происходит экспоненциальное количество вызовов, так как одни значения вычисляются многократно. С мемоизацией каждое значение вычисляется один раз и сохраняется, что уменьшает сложность до линейной.

Таким образом, мемоизация помогает повысить производительность, снижает время выполнения и нагрузку на процессор, особенно в задачах с повторяющимися вычислениями и рекурсией.


