# Бинарная куча
Бинарная куча — это полное двоичное дерево, где все уровни, кроме последнего, полностью заполнены, а последний уровень заполняется слева направо. Оно подчиняется свойству порядка: значение каждого узла не меньше (в случае max-heap) или не больше (для min-heap) значений его потомков.
В Python бинарная куча реализуется c помощью списка и модуля heapq, где родительский элемент всегда меньше или равен дочерним. Однако heapq поддерживает только минимальные кучи; чтобы создать максимальную, необходимо инвертировать значения. Можно также реализовать собственный класс кучи. Пользователь видит не дерево, а одномерный список, который логически представляет собой кучу. Метод heappush(list, item) добавляет элемент на позицию, сохраняющую свойство кучи, а heappop(list) извлекает и удаляет минимальный элемент.
В C++ бинарная куча реализована как полное бинарное дерево через std::priority_queue или std::vector. Функция push добавляет элемент в конец массива, затем «поднимает» его вверх до соблюдения свойства кучи. Операция pop удаляет корневой элемент.
В Java бинарная куча представлена классом PriorityQueue, который использует внутренний массив и не предоставляет к нему прямого доступа. Добавление выполняется через add(item) или offer(item), просмотр без удаления — через peek(), а извлечение минимального элемента — с помощью poll().

# Биномиальная куча
Биномиальная куча — структура данных, реализующая очередь с приоритетом. Она состоит из набора биномиальных деревьев, где каждое удовлетворяет свойству: ключ вершины не меньше ключа её родителя, а размеры всех деревьев различаются.
В Python стандартной реализации нет, поэтому её создают вручную, определяя классы для узлов и самой кучи (BinomialHeap). Основные методы: insert(key) создаёт узел и бинарное дерево степени 0, getMin() ищет минимальный элемент среди корней, а merge(heap1, heap2) объединяет кучи, сортируя деревья по степеням.
В C++ и Java стандартных реализаций также нет. В обоих языках куча создаётся как набор биномиальных деревьев с методами insert, getMin, extractMin, merge и decreaseKey. В Java добавляется объектно-ориентированный подход с автоматическим управлением памятью.
# Куча Фибоначчи
Куча Фибоначчи — структура для очередей с приоритетом, представляющая собой набор деревьев произвольной формы, удовлетворяющих свойству кучи: ключ родителя не превышает ключей потомков (для min-heap). Корни деревьев образуют циклический двусвязный список, а некоторые операции (например, объединение) откладываются до необходимости.
В Python реализуется вручную с помощью классов FibonacciNode и FibonacciHeap. В C++ используется структура Node и класс FibonacciHeap, где есть методы isEmpty(), getMin(), unite(), extractMin(), decreaseKey() и deleteElement(). Списки left/right образуют кольцо, что облегчает добавление и удаление элементов.
В Java куча Фибоначчи создаётся аналогично — через классы FibonacciNode и FibonacciHeap. Также может включать метод fibonacci(long n) для рекурсивного вычисления чисел Фибоначчи.
#Хеш-таблица
Хеш-таблица — структура данных для хранения пар «ключ‑значение» с быстрым поиском по ключу. Основные этапы работы:
– хеширование (ключ преобразуется в целое число с помощью хеш‑функции);
– индексация (хеш используется как индекс массива);
– разрешение коллизий (при совпадении индексов применяются цепочки или открытая адресация).
# В Python возможны два варианта реализации.
Класс‑реализация, где таблица — это список, а хеш-функция вычисляет остаток от деления ASCII-кода первого символа ключа на размер таблицы. Методы: set(), get(), remove(). Ключами могут быть только неизменяемые типы данных.
Собственная реализация через массив бакетов (ячейки с ключом, значением и хешем). Методы разрешения коллизий включают перезапись, цепочки через LinkedList, открытую адресацию и двойное хеширование.
В C++ есть контейнер std::unordered_map, основанный на цепочечном хешировании, и возможность ручной реализации через массив списков. Основные операции: вставка, поиск, удаление, проверка на наличие ключа.
В Java реализована через классы Hashtable и HashMap. Hashtable сопоставляет ключи со значениями напрямую, а HashMap использует массив односвязных списков и поддерживает методы put, get, getOrDefault, containsKey, remove, putAll.
