Дерево — это иерархическая структура данных, состоящая из узлов, где каждый элемент (кроме корня) связан ровно с одним родителем и может иметь несколько дочерних узлов; корень не имеет родителя, а листовые узлы не содержат потомков. Данная структура широко применяется для организации файловых систем и построения организационных диаграмм.
Граф — это более гибкая, нелинейная структура данных, в которой элементы представлены вершинами, а связи между ними — рёбрами. Формально граф обозначается как G=(U,E), где U — множество вершин, а E — множество рёбер; каждое ребро определяется парой e=[x,y]. Существуют разные типы графов: ориентированные и неориентированные, взвешенные и невзвешенные.
Во всех языках программирования бинарное дерево реализуется через узлы, которые содержат ключ и ссылки на левого и правого потомков. Операции вставки, поиска и удаления могут быть реализованы рекурсивным и нерекурсивным методом. В Python обычно используется класс Node с полями key, left и right, где отсутствие потомков представлено значением None; класс дерева содержит root и реализует основные методы как рекурсивно, так и без использования рекурсии, 
включая вспомогательные вроде поиска минимума (find_min) для удаления элементов. В Java реализуются внутренние статические классы Node с соответствующими полями, а само дерево хранит ссылку на корень; добавление элементов проводится через рекурсивный метод doInsert или итеративный спуск, поддерживая обработку пустых или дублирующихся узлов. В C++ задаётся структура TNode с указателями на потомков и рекомендуется использовать списки инициализации и nullptr для отсутствующих связей;
класс дерева снабжается деструктором для корректного освобождения памяти, а итеративная вставка может быть реализована через указатель на указатель (TNode**).
Для графов и классических задач на кратчайший путь, таких как алгоритм Дейкстры, разрабатываются различные реализации: матрица смежности либо список смежности в связке с приоритетной очередью. В Python граф обычно хранится как словарь, где ключи — вершины, а значения — словари соседей с их весами; для Дейкстры используется heapq (минимальная куча), начальные расстояния устанавливаются в бесконечность, а значения пересчитываются при обработке вершин с минимальным расстоянием. 
В Java практикуются варианты с матрицей смежности (массивы visited и distance вместе с функцией поиска минимума) или списками смежности (ArrayList[]) в сочетании с PriorityQueue; к весу до вершины добавляется поле wsf (weight so far). В C++ граф хранится во вложенных vector, каждый элемент — структура с destination и weight, для приоритетной очереди используется компаратор для минимизации пути, а массивы distances и previous позволяют не только узнавать стоимость, но и восстанавливать сам путь.

# Пример реализации алгоритма Дейкстры на Python:
Импорт модуля heapq для работы с приоритетной очередью (min-heap).
Все расстояния инициализируются значением бесконечности, для стартовой вершины задаётся 0.
Приоритетная очередь инициализируется кортежем (0, start).
В основном цикле вершина с минимальным расстоянием извлекается из кучи; если найдено устаревшее значение — оно пропускается.
Для каждого соседа текущей вершины проводится релаксация: если новое расстояние оказывается меньше, оно заменяет прежнее в таблице и помещается в кучу.
Сложность при использовании min-heap: O(n log n), обусловлено максимум V извлечениями и до E вставками по логарифмической стоимости.
# В C++ используется STL-библиотека:
Заголовочные файлы для vector (список смежности), priority_queue (минимальная куча) и numeric_limits (для ∞).
Дистанции до всех вершин устанавливаются равными бесконечности, источник равен нулю.
Очередь приоритетов заполняется парой (0, s).
В цикле на каждом шаге извлекается вершина с минимальным значением дистанции; устаревшие значения пропускаются.
Для каждого инцидентного ребра производится релаксация, если достигается более короткий путь, обновляется дистанция и пара вновь помещается в очередь.
Итоговая сложность составляет O(n log n) за счёт логарифмической вставки и изъятия элементов.
# В Java применяются ArrayList[] и PriorityQueue c переопределением compareTo для сортировки по весу, а массив visited отслеживает уже обработанные вершины:
Импортируются коллекции и PriorityQueue.
Классы Edge (ребро с весом) и Pair (вершина + wsf) формируют структуру графа и элементов очереди.
Массивы дистанций заполняются максимальными значениями, а boolean[] отмечает незафиксированные вершины.
Источник помещается в очередь с нулевым весом.
В цикле извлекается вершина, если уже обработана — пропускается; иначе для всех её соседей производится релаксация и, если требуется, добавление в очередь.
Общая сложность идентична: O(n log n).