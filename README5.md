# Рекурсивная функция для нахождения макс эл в массиве 

# Алгоритм работы:
1) Базовый случай рекурсии:
Когда длина массива равна 1, функция возвращает этот элемент как максимум, ведь больше сравнивать нечего. Это условие завершает рекурсию и запускает обратный возврат значений.
```
if len(arr) == 1:
    return arr[0]
```
2)Рекурсивный вызов:
Функция вызывает саму себя для оставшейся части массива — всех элементов, кроме первого. Так задача уменьшается с каждым шагом, пока не достигнет базового случая.
```
max_rest = find_max(arr[1:])
```
3)Сравнение результатов:
Когда найден максимум остальной части массива (переменная max_rest), сравнивается первый элемент с ним и возвращается больший.
```
return arr[0] if arr[0] > max_rest else max_rest
```
4)Рекурсивный процесс:
Алгоритм делит исходный массив на всё меньшие части, пока не останется один элемент. Затем при возврате из рекурсии на каждом уровне происходит сравнение: выбирается максимальный элемент между текущим первым и максимумом оставшейся части. Этот шаг реализуется на каждом уровне вызова.
```
return arr[0] if arr[0] > find_max(arr[1:]) else find_max(arr[1:])
```
5)Принцип «разделяй и властвуй»:
Задача делится на подзадачи — массив без первого элемента. Каждая подзадача решается отдельно через рекурсивный вызов, а результат объединяется через сравнение максимумов. Такой подход иллюстрирует стратегию «разделяй и властвуй».
```
max_left = find_max([arr[0]])
max_right = find_max(arr[1:])
return max_left if max_left > max_right else max_right
```
# Временная сложность:
O(n²)
# Почему O(n²):
-Каждый рекурсивный вызов find_max(arr[1:]) создает новый срез массива, копируя все элементы, кроме первого. Создание среза требует времени O(k), где k — длина создаваемого среза.
-В первой итерации копируется массив длиной n−1, во второй — n−2, и так далее, до длины 1.
-Итоговое время копирования составит сумму:(n−1)+(n−2)+…+1=((n−1)n)/2=O(n²)
-Каждое сравнение само по себе занимает O(1), но накладные расходы на создание срезов доминируют.

# Ответ на контрольный вопрос (номер 4)
Мемоизация — это метод оптимизации рекурсивных алгоритмов, при котором результаты функций сохраняются (кэшируются) после первого вычисления с определёнными аргументами. При повторном вызове с теми же параметрами программа не выполняет повторные вычисления, а сразу возвращает сохранённый результат из кэша.
Это существенно ускоряет работу рекурсивных алгоритмов, которые часто вызывают одни и те же функции с одинаковыми аргументами, уменьшая избыточные вычисления. Например, при вычислении чисел Фибоначчи без мемоизации происходит экспоненциальное количество вызовов, так как одни значения вычисляются многократно. С мемоизацией каждое значение вычисляется один раз и сохраняется, что уменьшает сложность до линейной.
Таким образом, мемоизация помогает повысить производительность, снижает время выполнения и нагрузку на процессор, особенно в задачах с повторяющимися вычислениями и рекурсией.

